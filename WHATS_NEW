What's new in symfony 1.3?
==========================

This tutorial is a quick technical introduction for symfony 1.3.
It is for developers who have already worked with symfony 1.2
and who want to quickly learn new features of symfony 1.3.

First, please note that symfony 1.3 is compatible with PHP 5.2.4 or later.

If you want to upgrade from 1.2, please read the
[UPGRADE](http://www.symfony-project.org/installation/1_3/upgrade) file
found in the symfony distribution.
You will have there all the information needed to safely upgrade
your projects to symfony 1.3.

Security
--------

When a new application is created with the `generate:app` task, the security
settings are now enabled by default:

  * `escaping_strategy`: The value is now `on` by default (can be disabled
    with the `--escaping-strategy` option).

  * `csrf_secret`: A random password is generated by default, and thus, the
    CSRF protection is enabled by default (can be disabled with the
    `--csrf-secret` option). It is highly recommended that you change the
    default generated password, by editing the `settings.yml` configuration
    file, or by using the `--csrf-secret` option.

Widgets
-------

### Default Labels

When a label is auto-generated from the field name, `_id` suffixes are now
removed:

  * `first_name` => First name (as before)
  * `author_id` => Author (was "Author id" before)

Validators
----------

### `sfValidatorRegex`

The `sfValidatorRegex` has a new `must_match` option. If set to `false`, the
regex must not match for the validator to pass.

### `sfValidatorSchemaCompare`

The `sfValidatorSchemaCompare` class has two new comparators:

 * `IDENTICAL`, which is equivalent to `===`;
 * `NOT_IDENTICAL`, which is equivalent to `!==`;

sfToolkit
---------

The `getTmpDir()` method has been deprecated and is no longer used in the
symfony core classes. You can replace usage of this method by the built-in
`sys_get_temp_dir()` PHP function. The `getTmpDir()` is now just a proxy to
this method.

This method will be removed in the symfony 1.4.

Forms
-----

### `sfForm::useFields()`

The new `sfForm::useFields()` method removes all non-hidden fields from a form
except the ones given as an argument. It is sometimes easier to explicitly
give the fields you want to keep in a form, instead of unsetting all unneeded
fields. For instance, when adding new fields to a base form, they won't
automagically appear in your form until explicitly added (think of a model
form where you add a new column to the related table).

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        $this->useFields(array('title', 'content'));
      }
    }

By default, the array of fields is also used to change the fields order. You
can pass `false` as the second argument to `useFields()` to disable the
automatic reordering.

### `sfFormSymfony`

The new `sfFormSymfony` class introduces the event dispatcher to symfony
forms. You can access the dispatcher from inside your form classes as
`self::$dispatcher`. The following form events are now notified by symfony:

  * `form.post_configure`:   This event is notified after every form is
                             configured
  * `form.filter_values`:    This event filters the merged, tainted parameters
                             and files array just prior to binding
  * `form.validation_error`: This event is notified whenever form validation
                             fails
  * `form.method_not_found`: This event is notified whenever an unknown method
                             is called

### `BaseForm`

Every new symfony 1.3 project includes a `BaseForm` class that you can use to
extend the Form component or add project-specific functionality. The forms
generated by `sfDoctrinePlugin` and `sfPropelPlugin` automatically extend this
class. If you create additional form classes they should now extend `BaseForm`
rather than `sfForm`.

### `sfForm::doBind()`

The cleaning of tainted parameters has been isolated in a developer-friendly
method, `->doBind()`, which receives the merged array of parameters and files
from `->bind()`.

### `sfForm(Doctrine|Propel)::doUpdateObject()`

The Doctrine and Propel form classes now include a developer-friendly
`->doUpdateObject()` method. This method receives an array of values from
`->updateObject()` that has already been processed by `->processValues()`.

Validators
----------

### Default Error Messages

You can now define default error messages globally by using the
`sfForm::setDefaultMessage()` method:

    [php]
    sfValidatorBase::setDefaultMessage('required', 'This field is required.');

The previous code will override the default 'Required.' message for all
validators. Note that the default messages must be defined before any
validator is created (the configuration class is a good place).

>**NOTE**
>The `setRequiredMessage()` and `setInvalidMessage()` methods are
>deprecated and call the new `setDefaultMessage()` method.

When symfony displays an error, the error message to use is determined as
follows:

  * Symfony looks for a message passed when the validator was created (via the
    second argument of the validator constructor);

  * If it is not defined, it looks for a default message defined with
    the `setDefaultMessage()` method;

  * If it is not defined, it falls back to the default message defined by the
    validator itself (when the message has been added with the `addMessage()`
    method).

Autoloaders
-----------

All symfony autoloaders are now case-insensitive. PHP is case-insensitive, now
so is symfony.

### `sfAutoloadAgain` (EXPERIMENTAL)

A special autoloader has been added that is just for use in debug mode. The
new `sfAutoloadAgain` class will reload the standard symfony autoloader and
search the filesystem for the class in question. The net effect is that you no
longer have to run `symfony cc` after adding a new class to a project.

Tests
-----

### Speed up Testing

When you have a large suite of tests, it can be very time consuming to launch
all tests every time you make a change, especially if some tests fail. That's
because each time you fix a test, you should run the whole test suite again to
ensure that you have not break something else. But as long as the failed tests
are not fixed, there is no point in re-executing all other tests. As of
symfony 1.3, the `test:all` and `symfony:test` tasks have a `--only-failed`
(`-f` as a shortcut) option that forces the task to only re-execute tests that
failed during the previous run:

    $ php symfony test:all --only-failed

Here is how it works: the first time, all tests are run as usual. But for
subsequent test runs, only tests that failed last time are executed. As you
fix your code, some tests will pass, and will be removed from subsequent runs.
When all tests pass again, the full test suite is run... you can then rinse
and repeat.

### Functional Tests

When a request generates an exception, the `debug()` method of the response
tester now outputs a readable text representation of the exception, instead of
the normal HTML output. It makes debugging much more easier.

`sfTesterResponse` has a new `matches()` method that runs a regex on the whole
response content. It is of great help on non XML-like responses, where
`checkElement()` is not useable. It also replaces the less-powerful
`contains()` method:

    [php]
    $browser->with('response')->begin()->
      matches('/I have \d+ apples/')->    // it takes a regex as an argument
      matches('!/I have \d+ apples/')->   // a ! at the beginning means that the regex must not match
      matches('!/I have \d+ apples/i')->  // you can also add regex modifiers
    end();

### JUnit Compatible XML Output

The test tasks are now able to output a JUnit compatible XML file by using the
`--xml` option:

    $ php symfony test:all --xml=log.xml

### Easy Debugging

To ease the debugging when a test harness reports failed tests, you can now
pass the `--trace` option to have a detailed output about the failures:

    $ php symfony test:all -t

### Lime Output Colorization

As of symfony 1.3, lime does the right thing as far as colorization is
concerned. It means, that you can almost always omit the second argument of
the lime constructor of `lime_test`:

    [php]
    $t = new lime_test(1);

### `sfTesterResponse::checkForm()`

The response tester now includes a method to easily verify that all fields in
a form have been rendered to the response:

    [php]
    $browser->with('response')->begin()->
      checkForm('ArticleForm')->
    end();

Or, if you prefer, you can pass a form object:

    [php]
    $browser->with('response')->begin()->
      checkForm($browser->getArticleForm())->
    end();

If the response includes multiple forms you have the option of providing a CSS
selector to pinpoint which portion of the DOM to test:

    [php]
    $browser->with('response')->begin()->
      checkForm('ArticleForm', '#articleForm')->
    end();

### Listen to `context.load_factories`

You can now add listeners for the `context.load_factories` event to your
functional tests. This was not possible in previous versions of symfony.

    [php]
    $browser->addListener('context.load_factories', array($browser, 'listenForNewContext'));

Tasks
-----

The symfony CLI now attempts to detect the width of your terminal window and
formats lines to fit. If detection is not possible the CLI defaults to 78
columns wide.

### `sfTask::askAndValidate()`

There is a new `sfTask::askAndValidate()` method to ask a question to the user
and validates its input:

    [php]
    $anwser = $this->askAndValidate('What is you email?', new sfValidatorEmail());

The method also accepts an array of options (see the API doc for more
information).

### `symfony:test`

From time to time, developers need to run the symfony test suite to check that
symfony works well on their specific platform. Until now, they had to know the
`prove.php` script bundled with symfony to do that. As of symfony 1.3, there
is a built-in task, `symfony:test` that launches the symfony core test suite
from the command line, like any other task:

    $ php symfony symfony:test

If you were used to run `php test/bin/prove.php`, you should now run the
equivalent `php data/bin/symfony symfony:test` command.

### `project:deploy`

The `project:deploy` task has been slightly improved. It now displays the
progress of the files transfer in real-time, but only if the `-t` option is
passed. If not, the task is silent, except for errors of course. Speaking of
errors, if one occurs, the output is on a red background to easy problem
identification.

### `generate:project`

As of symfony 1.3, Doctrine is the default configured ORM when executing the
`generate:project` task:

    $ php /path/to/symfony generate:project foo

To generate a project for Propel, use the `--orm` option:

    $ php /path/to/symfony generate:project foo --orm=Propel

If you don't want to use Propel or Doctrine, you can pass `none` to the
`--orm` option:

  $ php /path/to/symfony generate:project foo --orm=none

The new `--installer` option allows you to pass a PHP script that can further
customize the newly created project. The script is executed in the context of
the task, and so can use any of its methods. The more useful ones are the
following: `installDir()`, `runTask()`, `ask()`, `askConfirmation()`,
`askAndValidate()`, `reloadTasks()`, `enablePlugin()`, and `disablePlugin()`.

More information can be found in this
[post](http://www.symfony-project.org/blog/2009/06/10/new-in-symfony-1-3-project-creation-customization)
from the official symfony blog.

### `sfFileSystem::execute()`

The `sfFileSystem::execute()` methods replaces the `sfFileSystem::sh()` method
with more powerful features. It takes callbacks for real-time processing of
the `stdout` and `stderr` outputs. It also returns both outputs as an array.
You can find one example of its usage in the `sfProjectDeployTask` class.

### `task.test.filter_test_files`

The `test:*` tasks now filter test files through the
`task.test.filter_test_files` event prior to running them. This event includes
`arguments` and `options` parameters.

### Enhancements to `sfTask::run()`

You can now pass an associative array of arguments and options to
`sfTask::run()`:

    [php]
    $task = new sfDoctrineConfigureDatabaseTask($this->dispatcher, $this->formatter);
    $task->run(array(
      'dsn' => 'mysql:dbname=mydb;host=localhost',
    ), array(
      'name' => 'master',
    ));

The previous version, which still works:

    [php]
    $task->run(array(
      'mysql:dbname=mydb;host=localhost',
    ), array(
      '--name=master',
    ));

### `sfBaseTask::setConfiguration()`

When calling a task that extends `sfBaseTask` from PHP, you no longer have to
pass `--application` and `--env` options to `->run()`. Instead, you can simply
set the configuration object directly by calling `->setConfiguration()`.

    [php]
    $task = new sfDoctrineLoadDataTask($this->dispatcher, $this->formatter);
    $task->setConfiguration($this->configuration);
    $task->run();

The previous version, which still works:

    [php]
    $task = new sfDoctrineLoadDataTask($this->dispatcher, $this->formatter);
    $task->run(array(), array(
      '--application='.$options['application'],
      '--env='.$options['env'],
    ));

### `project:disable` and `project:enable`

You can now wholesale disable or enable an entire environment using the
`project:disable` and `project:enable` tasks:

    $ php symfony project:disable prod
    $ php symfony project:enable prod

You can also specify which applications to disable in that environment:

    $ php symfony project:disable prod frontend backend
    $ php symfony project:enable prod frontend backend

These tasks are backward compatible with their previous signature:

    $ php symfony project:disable frontend prod
    $ php symfony project:enable frontend prod

Exceptions
----------

### Autoloading

When an exception is thrown during autoloading, symfony now catch them and
outputs an error to the user. That should solve some "White screen of death"
pages.

Propel
------

### `propel:insert-sql`

Before `propel:insert-sql` removes all data from a database, it asks for a
confirmation. As this task can remove data from several databases, it now also
displays the name of the connections of the related databases.

### `isPrimaryString` column attribute

You can now include an `isPrimaryString` attribute in `schema.yml` and symfony
will generate a `__toString()` method in the model class that returns the
value of that column.

    [yml]
    classes:
      Article:
        columns:
          id:     ~
          title:  { type: varchar(255), isPrimaryString: true }
          body:   { type: longvarchar }

This configuration will result in the following method in `BaseArticle`:

    [php]
    public function __toString()
    {
      return $this->getTitle();
    }

Routing
-------

### Default Requirements

The default `\d+` requirement is now only applied to a
`sfObjectRouteCollection` when the `column` option is the default `id`. This
means you no longer have to provide an alternate requirement when a
non-numeric column is specified (i.e. `slug`).

CLI
---

### Output Colorization

Symfony tries to guess if your console supports colors when you use the
symfony CLI tool. But sometimes, symfony guesses wrong; for instance when you
use Cygwin (because colorization is always turned off on the Windows
platform).

As of symfony 1.3, you can force the use of colors for the output by passing
the global `--color` option.

I18N
----

### Data update

The data used for all I18N operations was updated from the `ICU project`.
Symfony comes now with about 330 locale files, which is an increase of about 70
compared to Symfony 1.2. Please note that the updated data might be slightly
different from what has been in there before, so for example test cases checking
for the tenth item in a language list might fail.

### Sorting according to user locale

All sorting on this locale dependend data is now also performed locale dependend.
`sfCultureInfo->sortArray()` can be used for that.

Plugins
-------

Before symfony 1.3, all plugins were enabled by default, except for the
`sfDoctrinePlugin` and the `sfCompat10Plugin` ones:

    [php]
    class ProjectConfiguration extends sfProjectConfiguration
    {
      public function setup()
      {
        // for compatibility / remove and enable only the plugins you want
        $this->enableAllPluginsExcept(array('sfDoctrinePlugin', 'sfCompat10Plugin'));
      }
    }

For freshly created projects with symfony 1.3, plugins must be explicitly
enabled in the `ProjectConfiguration` class to be able to use them:

    [php]
    class ProjectConfiguration extends sfProjectConfiguration
    {
      public function setup()
      {
        $this->enablePlugins('sfDoctrinePlugin');
      }
    }

The `plugin:install` task automatically enables the plugin(s) it installs (and
`plugin:uninstall` disable them). If you install a plugin via Subversion, you
still need to enable it by hand.

If you want to use a core-plugin, like `sfProtoculousPlugin` or
`sfCompat10Plugin`, you just need to add the corresponding `enablePlugins()`
statement in the `ProjectConfiguration` class.

>**NOTE**
>If you upgrade a project from 1.2, the old behavior will still be
>active as the upgrade task does not change the `ProjectConfiguration`
>file. The behavior change is only for new symfony 1.3 projects.

### `sfPluginConfiguration::connectTests()`

You can connect a plugin's tests to the `test:*` tasks by calling that plugin
configuration's `->connectTests()` method.

    [php]
    class ProjectConfiguration extends sfProjectConfiguration
    {
      public function loadPlugins()
      {
        parent::loadPlugins();
        $this->pluginConfigurations['sfExamplePlugin']->connectTests();
      }
    }

Settings
--------

### `sf_file_link_format`

Symfony 1.3 formats file paths as clickable links whenever possible (i.e. the
debug exception template). The `sf_file_link_format` is used for this purpose,
if set, otherwise symfony will look for the `xdebug.file_link_format` PHP
configuration value.

For example, if you want to open files in TextMate, add the following to
`settings.yml`:

    [yml]
    all:
      .settings:
        file_link_format: txmt://open?url=file://%f&line=%l

The `%f` placeholder will be replaced with file's absolute path and the `%l`
placeholder will be replaced with the line number.

Doctrine Integration
--------------------

### Generating Form Classes

It is now possible to specify additional options for symfony in your Doctrine YAML
schema files. We've added some options to disable the generation of form and filter
classes.

For example in a typical many to many reference model, you don't need any form 
or filter form classes generated. So you can now do the following.

    UserGroup:
      options:
        symfony:
          form: false
          filter: false
      columns:
        user_id:
          type: integer
          primary: true
        group_id:
          type: integer
          primary: true

### Form Classes Inheritance

When you generate forms from your models, and your models contain inheritance. 
The generated child classes will respect the inheritance and generate forms
that follow the same inheritance structure.

### New Tasks

We have introduced a few new tasks to help you when developing with Doctrine.

#### Create Model Tables

You can now individually create the tables for a specified array of models. It 
will drop the tables first then re-create them for you. This is useful if you
are developing some new models in an existing project/database and you don't
want to blow away the whole database and just want to rebuild a subset of tables.

    $ php symfony doctrine:create-model-tables Model1 Model2 Model3

#### Delete Model Files

Often you will change your models, renaming things, remove unused models, etc. 
in your YAML schema files. When you do this, you then have orphaned model, form
and filter classes. You can now manually clean out the generated files related 
to a model by using the `doctrine:delete-model-files` task.

    $ php symfony doctrine:delete-model-files ModelName

The above task will find all the related generated files and report them to you 
before asking you to confirm whether you would like to delete the files or not.

#### Clean Model Files

You can automate the above process and find out what models exist on the disk 
but do not exist in your YAML schema files by using the `doctrine:clean-model-files`
task.

    $ php symfony doctrine:clean-model-files

The above command will compare your YAML schema files with the models and files
that have been generated and determine what should be removed. These models are 
then passed on to the `doctrine:delete-model-files` task. It will ask you to 
confirm the removal of any files before actually deleting anything.

#### Reload Data

It is a common need to want to blow away the databases completely then reload
your data fixtures. The `doctrine:build-all-reload` task does this but it also
does a bunch of other work, generating models, forms, filters, etc. and this
can be time consuming in a large project. Now you can simply use the 
`doctrine:reload-data` task.

The following command.

    $ php symfony doctrine:reload-data

Is equivalent to running these commands:

    $ php symfony doctrine:drop-db
    $ php symfony doctrine:build-db
    $ php symfony doctrine:insert-sql
    $ php symfony doctrine:data-load

#### New option: `--migrate`

The following tasks now include a `--migrate` option, which will replace the
nested `doctrine:insert-sql` task with `doctrine:migrate`.

  * `doctrine:build-all`
  * `doctrine:build-all-load`
  * `doctrine:build-all-reload`
  * `doctrine:build-all-reload-test-all`
  * `doctrine:rebuild-db`
  * `doctrine:reload-data`

### Date Setters and Getters

We've added two new methods for retrieving Doctrine date or timestamp values as
PHP DateTime object instances.

    [php]
    echo $article->getDateTimeObject('created_at')
      ->format('m/d/Y');

You can also set a dates value by simply calling the `setDateTimeObject` method
and passing a valid `DateTime` instance.

    [php]
    $article->setDateTimeObject('created_at', new DateTime('09/01/1985'));

### Output DQL Task as Table of Data

When you would previously run the `doctrine:dql` command it will just output the
data as YAML. We have added a new `--table` option. This option allows you to 
output the data as a table, similar to how it ouputs in the MySQL command line.

So now the following is possible.

    $ ./symfony doctrine:dql "FROM Article a" --table
    >> doctrine  executing dql query
    DQL: FROM Article a
    +----+-----------+----------------+---------------------+---------------------+
    | id | author_id | is_on_homepage | created_at          | updated_at          |
    +----+-----------+----------------+---------------------+---------------------+
    | 1  | 1         |                | 2009-07-07 18:02:24 | 2009-07-07 18:02:24 |
    | 2  | 2         |                | 2009-07-07 18:02:24 | 2009-07-07 18:02:24 |
    +----+-----------+----------------+---------------------+---------------------+
    (2 results)

### Debugging queries in functional tests

The `sfTesterDoctrine` class now includes a `->debug()` method. This method
will output information about that queries that have been run in the current
context.

    [php]
    $browser->
      get('/articles')->
      with('doctrine')->debug()
    ;

You can view only the last few queries executed by passing an integer to the
method, or show only queries that contain a substring or match a regular
expression by passing a string.

    [php]
    $browser->
      get('/articles')->
      with('doctrine')->debug('/from articles/i')
    ;

Web Debug Toolbar
-----------------

### `sfWebDebugPanel::setStatus()`

Each panel in the web debug toolbar can specify a status that will affect its
title's background color. For example, the background color of the log panel's
title changes if any messages with a priority greater than `sfLogger::INFO`
are logged.

### `sfWebDebugPanel` request parameter

You can now specify a panel to be open on page load by appending a
`sfWebDebugPanel` parameter to the URL. For example, appending
`?sfWebDebugPanel=config` would cause the web debug toolbar to render with the
config panel open.

Panels can also inspect request parameters by accessing the web debug
`request_parameters` option:

    [php]
    $requestParameters = $this->webDebug->getOption('request_parameters');

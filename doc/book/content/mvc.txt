MVC implementation explained
============================

Overview
--------

The symfony framework relies on the best practices of web development, and especially on the MVC model (Model/View/Controller). This chapter describes the general functioning of the symfony framework and the paradigm it relies on.

Concepts
--------

The base of symfony is a classic web design pattern, the [MVC architecture][1], which has three levels: 

* the **Model** represents the information on which the application operates, its business logic
* the **View** renders the model into a web page suitable for interaction with the user
* the **Controller** responds to user actions, and invokes changes on the model or view as appropriate

In symfony, the Controller is separated in different parts, namely a front controller and a set of actions. Each action knows how to handle a specific kind of request. The View is separated in layouts, templates and partials - all those are PHP files that have access to the content defined in the Action. The Model offers an abstraction layer to databases and useful information about the session and the requests. 

This model you helps to work separately on the business logic (Model) and on the presentation (View). For instance, if you need an application to run both on standard web browsers and on handheld devices, you just need a new View but you can keep the original Controller and Model. The Controller helps to hide the details of the protocol used for the request (HTTP, console mode, mail, etc.) from the Model and the View. And the Model abstracts the logic of the data, which makes the View and the Action independent of, for instance, the type of database used by the application.

Symfony implements the MVC model in a simple and light way so that developers get the benefits of shortcut conventions and agile programming without unnecessary slowdowns of the application itself.

Example
-------

To make things clear, let's see how the symfony implementation of the MVC architecture works for an *add to cart* interaction. 

1. First, the user interacts with the user interface by selecting a product and pressing a button; this probably validates a form and sends a web request to the server. 

2. The Front Controller then receives the notification of the user action and, after executing general procedures on this request (regarding routing, security, etc.), understands that it need to be passed to the 'shopping cart' action.

3. The 'shopping cart' Action accesses the Model, to update the 'cart' object of the user session.

4. As the modification of the stored data is successful, the action prepares the content that will be included in the response - confirmation of the addition and complete list of products currently in the shopping cart. The 'shopping cart' action logic specifies that for a product addition, the content has to be included into a 'shopping cart' template.

5. The View then assembles the answer from the action and the skinning from the template to produce the HTML code of the shopping cart page.

6. It is finally transferred to the web server that sends it to the user, who will use his browser to read and interact with the new information.

Symfony classes
---------------

The names of the classes that are part of the symfony package are prefixed by `sf`. You can find these default classes in your symfony/lib installation directory.

    sfAction
    sfRequest
    sfView
    ...
    
If you need to add custom methods to these classes for a given project, modify the `my`-prefixed classes that can be found in the `myproject/apps/myapp/lib` directory:

    myAction
    myRequest
    myView
    ...

These classes inherit the `sf`-ones and support extension.

>**Note**: the names of the framework classes that will be called during execution are specified in the `factories.yml` application configuration file.

[1]: http://en.wikipedia.org/wiki/Model-view-controller "Model-View-Controller definition at Wikipedia"
